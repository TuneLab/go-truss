{{ with $templateExecutor := .}}
package addsvc

// This file provides server-side bindings for the HTTP transport.
// It utilizes the transport/http.Server.

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"io/ioutil"
	"net/http"
	"net/url"
	"strconv"
	"strings"

	//stdopentracing "github.com/opentracing/opentracing-go"
	"golang.org/x/net/context"

	//"github.com/go-kit/kit/log"
	//"github.com/go-kit/kit/tracing/opentracing"
	httptransport "github.com/go-kit/kit/transport/http"

	// This service
	pb "{{$templateExecutor.GeneratedImport -}} /pb"
)

var (
	_ = fmt.Sprint
	_ = strconv.Atoi
	_ = httptransport.NewServer
)

// MakeHTTPHandler returns a handler that makes a set of endpoints available
// on predefined paths.
func MakeHTTPHandler(ctx context.Context, endpoints Endpoints/*, tracer stdopentracing.Tracer, logger log.Logger*/) http.Handler {
	/*options := []httptransport.ServerOption{
		httptransport.ServerErrorEncoder(errorEncoder),
		httptransport.ServerErrorLogger(logger),
	}*/
	m := http.NewServeMux()

{{range $method := $templateExecutor.HTTPHelper.Methods}}
{{range $binding := $method.Bindings}}
	m.Handle("{{ToLower $binding.BasePath}}", httptransport.NewServer(
		ctx,
		endpoints.{{$method.Name}}Endpoint,
		DecodeHTTP{{$binding.Label}}Request,
		EncodeHTTPGenericResponse,
	))
{{- end}}
{{- end}}
	return m
}

func errorEncoder(_ context.Context, err error, w http.ResponseWriter) {
	code := http.StatusInternalServerError
	msg := err.Error()

	/*if e, ok := err.(httptransport.Error); ok {
		msg = e.Err.Error()
		switch e.Domain {
		case httptransport.DomainDecode:
			code = http.StatusBadRequest

		case httptransport.DomainDo:
			switch e.Err {
			case ErrTwoZeroes, ErrMaxSizeExceeded, ErrIntOverflow:
				code = http.StatusBadRequest
			}
		}
	}*/

	w.WriteHeader(code)
	json.NewEncoder(w).Encode(errorWrapper{Error: msg})
}

func errorDecoder(r *http.Response) error {
	var w errorWrapper
	if err := json.NewDecoder(r.Body).Decode(&w); err != nil {
		return err
	}
	return errors.New(w.Error)
}

type errorWrapper struct {
	Error string `json:"error"`
}

// Server Decode
{{range $method := $templateExecutor.HTTPHelper.Methods}}
{{range $binding := $method.Bindings}}
// DecodeHTTP{{$method.Name}}Request is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded {{ToLower $method.Name}} request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTP{{$binding.Label}}Request(_ context.Context, r *http.Request) (interface{}, error) {
	var req pb.{{GoName $method.RequestType}}
	err := json.NewDecoder(r.Body).Decode(&req)

	pathParams, err := PathParams(r.URL.Path, "{{$binding.PathTemplate}}")
	_ = pathParams
	// TODO: Better error handling
	if err != nil {
		return nil, err
	}
	queryParams, err := QueryParams(r.URL.Query())
	_ = queryParams
	// TODO: Better error handling
	if err != nil {
		return nil, err
	}
{{range $field := $binding.Fields}}
	{{$field.LocalName}}Str := {{$field.Location}}Params["{{$field.Name}}"]
	{{$field.ConvertFunc}}
	// TODO: Better error handling
	if err != nil {
		return nil, err
	}
	req.{{GoName $field.Name}} = {{$field.LocalName}}
{{end}}


	return req, err
}
{{end}}
{{end}}

// Client Decode
{{range $i := $templateExecutor.Service.Methods}}
// DecodeHTTP{{$i.GetName}} is a transport/http.DecodeResponseFunc that decodes
// a JSON-encoded {{ToLower $i.GetName}} response from the HTTP response body.
// If the response has a non-200 status code, we will interpret that as an
// error and attempt to decode the specific error message from the response
// body. Primarily useful in a client.
func DecodeHTTP{{$i.GetName}}Response(_ context.Context, r *http.Response) (interface{}, error) {
	if r.StatusCode != http.StatusOK {
		return nil, errorDecoder(r)
	}
	var resp pb.{{GoName $i.ResponseType.GetName}}
	err := json.NewDecoder(r.Body).Decode(&resp)
	return resp, err
}
{{end}}

// Client Encode
{{range $method := $templateExecutor.HTTPHelper.Methods}}
{{range $binding := $method.Bindings}}
// EncodeHTTP{{$binding.Label}}Request is a transport/http.EncodeRequestFunc
// that encodes a {{ToLower $method.Name}} request into the various portions of
// the http request (path, query, and body).
func EncodeHTTP{{$binding.Label}}Request(_ context.Context, r *http.Request, request interface{}) error {
	req := request.(pb.{{GoName $method.RequestType}})
	_ = req

	// Set the path parameters
	path := strings.Join([]string{
{{range $section := $binding.PathSections}}
{{- $section -}},
{{end}}
	}, "/")
	u, err := url.Parse(path)
	if err != nil {
		return err
	}
	r.URL = u
	var buf bytes.Buffer
	if err := json.NewEncoder(&buf).Encode(request); err != nil {
		return err
	}
	r.Body = ioutil.NopCloser(&buf)
	return nil
}
{{end}}
{{end}}

// EncodeHTTPGenericResponse is a transport/http.EncodeResponseFunc that encodes
// the response as JSON to the response writer. Primarily useful in a server.
func EncodeHTTPGenericResponse(_ context.Context, w http.ResponseWriter, response interface{}) error {
	return json.NewEncoder(w).Encode(response)
}

{{$templateExecutor.HTTPHelper.PathParamsBuilder}}


{{- end}}
